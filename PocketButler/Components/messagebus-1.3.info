{"Name":"MessageBus","Id":1149,"Alias":"messagebus","Description":"MessageBus is a cross platform EventBus system similar to NSNoticationCenter on iOS and otto on Android that allows you to decouple your code whilst still allowing your applications components to communicate with each other.  MesssageBus can be used instead of events and can be used to communicate between objects that are not directly linked.\n\n# Features\n\n* Cross platform  \n  * Works on iOS, Android, Windows Phone, Mac and Windows\n* Small footprint\n* Simple API\n* Create custom events to easily pass additional data\n* Allows you to decouple objects and classes within your projects  \n* Portable Class library\n\n\n## Usage\n\n`MessageBus.Default` provides a central Multi-thread singleton for you to subscribe to and post events.  You can use this or have multiple separate `MessageBus` objects of your own.\n\n\n\tusing DSoft.Messaging;\n\t...\n\t\n\tvar newBus = new MessageBus();\n\t \n\nTo subscribe to an event you can create a `MessageBusEventHandler` object, and then register it with the MessageBus.  The event handler allows you to set the Id of the event to subscribe to and an Action or Delegate to call be when the event occurs.\n\n\tusing DSoft.Messaging;\n\t...\n\t\n\tvar newEvHandler = new MessageBusEventHandler()\n\t{\n\t\tEventId = \"1234\",\n\t\tAction = (sender, data) =\u003e\n\t\t{\n\t\t\t//Code goes here\n\t\t},\n\t};\n\t\n\tMessageBus.Default.Register(newEvHandler);\n\t\nYou can then post an event from anywhere in your application using the Id of the event to execute the Action in the registered `MessageBusEventHandler` objects.\n\nTo post an event you create an instance of `CoreMessageBusEvent`, set the EventId, sender and any additional data you want to send and then call Post on the relevant MessageBus.\n \n\tusing DSoft.Messaging;\n\t...\n\t\n\tvar newEvent = new CoreMessageBusEvent()\n\t{\n\t\tEventId = \"1234\",\n\t\tSender = this,\n\t\tData = new object[]{\"This is a message\"},\n\t};\n\t\n\tMessageBus.Default.Post(newEvent);\n\t ","Version":"1.3","Summary":"Cross platform EventBus framework for iOS, Android, Windows Phone and Mac","QuickStart":"\nMessageBus is a cross platform EventBus system similar to NSNoticationCenter on iOS and otto on Android that allows you to decouple your code whilst still allowing your applications components to communicate with each other.  MesssageBus can be used instead of events and can be used to communicate between objects that are not directly linked.\n\n## Usage\n\n`MessageBus.Default` provides a central Multi-thread singleton for you to subscribe to and post events.  You can use this or have multiple separate `MessageBus` objects of your own.\n\n\n\tusing DSoft.Messaging;\n\t...\n\t\n\tvar newBus = new MessageBus();\n\t \n**Registering Event Handlers**\n\nTo subscribe to an event you can create a `MessageBusEventHandler` object and then register it with the MessageBus.  The event handler allows you to set the Id of the event to subscribe to and an Action or Delegate to call be when the event occurs.\n\n\tusing DSoft.Messaging;\n\t...\n\t\n\tvar newEvHandler = new MessageBusEventHandler()\n\t{\n\t\tEventId = \"1234\",\n\t\tAction = (sender, evnt) =\u003e\n\t\t{\n\t\t\t//Code goes here\n\t\t},\n\t};\n\t\n\tMessageBus.Default.Register(newEvHandler);\n\nYou can then deregister an event handler or simply clear all handlers for a specific EventId\n\n\n\tusing DSoft.Messaging;\n\t...\n\n\t//deregister\n\tMessageBus.Default.DeRegister(newEvHandler);\n\t\n\t//Clear all event handlers\n\tMessageBus.Default.Clear(\"1234\");\n\n*Note: You must execute any code that updates the UI, contained within your event action or delegate, on the UI thread*\n\n**Posting Events**\n\nYou can then post an event from anywhere in your application using the Id of the event to execute the Action in the registered `MessageBusEventHandler` objects.\n\nTo post an event you create an instance of `CoreMessageBusEvent`, set the EventId, sender and any additional data you want to send and then call Post on the relevant MessageBus.\n \n\tusing DSoft.Messaging;\n\t...\n\t\n\tvar newEvent = new CoreMessageBusEvent()\n\t{\n\t\tEventId = \"1234\",\n\t\tSender = this,\n\t\tData = new object[]{\"This is a message\"},\n\t};\n\t\n\tMessageBus.Default.Post(newEvent);\n\nYou can also post an event with just the EventId, with the EventId and the sender or EventId, Sender and data, without creating a CoreMessageBusEvent object\n\n\tusing DSoft.Messaging;\n\t...\n\t\n\tMessageBus.Default.Post(\"1234\");\n\tMessageBus.Default.Post(\"1234\",this);\n\tMessageBus.Default.Post(\"1234\",this, new object[]{\"This is a message\"});\n\t\nIf you are only using the default MessageBus you can post using the class methods instead.\n\n\tusing DSoft.Messaging;\n\t...\n\t\n\tvar newEvent = new CoreMessageBusEvent()\n\t{\n\t\tEventId = \"1234\",\n\t\tSender = this,\n\t\tData = new object[]{\"This is a message\"},\n\t};\n\t\n\tMessageBus.PostEvent(newEvent);\n\tMessageBus.PostEvent(\"1234\");\n\tMessageBus.PostEvent(\"1234\",this);\n\tMessageBus.PostEvent(\"1234\",this, new object[]{\"This is a message\"});\n\n**UI Thread**  \nYou must execute any code that updates the UI, contained within your event action or delegate, on the UI thread*\n\nThis is an example on iOS withing a `UIView` but other platforms have a similar concept.\n\n\tusing DSoft.Messaging;\n\t...\n\t\n\tvar newEvHandler = new MessageBusEventHandler()\n\t{\n\t\tEventId = \"1234\",\n\t\tAction = (sender, evnt) =\u003e\n\t\t{\n\t\t\t//Code goes here\n\t\t\tBeginInvokeOnMainThread (() =\u003e {\n\t\t\t\t//post to the output box\n\t\t\t\ttxtOutput.Text += data2 + Environment.NewLine;\n\t\t\t});\n\t\t},\n\t};\n\t\n**Custom Events**\t\n\nYou can sub-class `MessageBusEvent` to allow you to pass additional information in the event, without having to pass it in the Data property.  \n\nYou can then register for events based on the type of the event, rather than the event Id.\n\n\n\tusing DSoft.Messaging;\n\t...\n\t\n\tMessageBus.Default.Register\u003cCustomMessageBusEvent\u003e (CustomMessageEventHandler);\n\n\tMessageBus.Default.Register\u003cCustomMessageBusEvent\u003e ((sendr, evnt) =\u003e {\n    \n      \t//code goes here\n\t});\n\nYou can also deregister based on type\n\n\tMessageBus.Default.DeRegister\u003cCustomMessageBusEvent\u003e (CustomMessageEventHandler);\n\n**Excuting code on the UI Thread**\n\nWhen MessageBus executes your action code it will not do it on the main UI Thread.  This is to avoid blocking of the UI for long running actions or where there are lots of handlers for an event.\n\nYou may wish to update you UI in the action code assigned to the Event Handler and you can do this two ways depending on where your event handler exists.\n\n - If your event handler is in \"Platform\" specific code you can use the current context to execute the code E.g. BeginInvokeOnMainThread(iOS), Actvity.RunOnUIThread(Android), Dispatcher.BeginInvoke(Windows Phone)\n - If your handler is in the PCL space you can use Task.Factory.StartNew and pass the current Syncronization context.  \n  \nAn example of the second approach is below.\n\n\tusing DSoft.Messaging;\n\t...\n\t\n\tvar newEvHandler = new MessageBusEventHandler()\n\t{\n\t\tEventId = \"1234\",\n\t\tAction = (sender, data) =\u003e\n\t\t{\n\t\t\t//Code goes here\n\t\t\tfor (int i = 1; i \u003c= 5; i++)\n\t        {\n\t            Console.WriteLine(i);\n\t        }\n\t        \n\t        //update the UI\n\t        Task.Factory.StartNew(() =\u003e\n            {\n                this.label1.Text = \"Task past first work section...\";\n            }, CancellationToken.None, TaskCreationOptions.None, TaskScheduler.FromCurrentSynchronizationContext());\n\t\t},\n\t};\n\t\n\tMessageBus.Default.Register(newEvHandler);\n\t\n ","Hash":"a86e9a00186ab747b862e6038d23d7a2","TargetPlatforms":["ios","android"],"TrialHash":null}